%% Rayleigh-Plesset solver (parallel bubble response computation)
% Demonstration of how to solve the response of multiple microbubbles with
% a single call to the ode solver. If the total number of microbubbles is
% too large to solve with a single call, the microbubbles can be
% distributed into batches. The bubble responses are computed with a
% Marmottant-type Rayleigh-Plesset equation, which takes viscous,
% radiation, shell, and thermal damping into account. The pulse shape is
% based on the pulse from the P4-1 transducer.
%
% Nathan Blanken, University of Twente, 2023

clear; clc; close all

dispFig = true;             % Display figures
dispProgress = true;    	% Show ODE solver progress

% Add the functions folder to path
addpath './functions'

% Get the transducer transfer functions of the P4-1 transducer
T = load('TransmitTransferFunctionFit.mat');

N_MB = 15; % Number of bubbles

% Divide the microbubbles into batches (only a limited number can be
% processed in parallel)
batchSize = 5;

%% Pulse properties
% Acoustic pressure amplitude (Pa):
PA = linspace(150e3, 250e3, N_MB);

Ncy = 1;                    % Total number of cycles
f = 1.7e6;              	% Centre frequency (Hz)
Fs = T.Fs;              	% Simulation sampling rate (Hz)
Tresp = 4e-6;               % Echo receive time after pulse (s)

% Simulate the pulses generated by a transducer with transfer function T,
% resulting from three-level driving signals. Get pulse struct with
% multiple waveforms:
pulse = getPulseMulti(f,Ncy,PA,Fs,Tresp,dispFig,T.Tfit);
pulse.tq = pulse.t; % Query times for ODE solver

% Show progress of bubble oscillation solver:
pulse.dispProgress = dispProgress;
pulse.batchSize = batchSize; % Batch size for the ODE solver

%% Material properties and environmental conditions
[liquid, gas] = getMaterialProperties();

% Select a thermal model: 'Adiabatic', 'Isothermal', or 'Propsperetti':
liquid.ThermalModel = 'Prosperetti';

%% Microbubble and shell properties

radii = 1.5e-6 + 1e-6*rand(1,N_MB); % Bubble radii (m):
r0 = 0.01;                  % Distance bubble to pressure sensor (m)

% Bubble properties (radius in meters):
bubble = arrayfun(@(x) struct('R0',x,'r0',r0), radii);

shellmodel = 'Segers';      % Marmottant, Segers, or SegersTable

% Typical value intial surface tension: Sijl et al., J. Acoust. Soc. Am.,
% 129, 1729 (2011)
sig0 = 10e-3;               % Equilibrium surface tension bubble (N/m);

% Shell properties:
shell = get_shell_properties_multi(bubble,shellmodel,sig0,liquid);

%% Bubble response

% Compute the radial response
[response, eqparam] = calcBubbleResponseBatched(liquid, ...
    gas, shell, bubble, pulse);

% Compute the scattered pressure
nearfield = false;    % Do not compute the rapidly decaying r^(-3) term.
for n = N_MB:-1:1
    scatter(n) = calc_scatter(...
        response(n),liquid,bubble(n),pulse,nearfield);
end

% Plot the results
plot_results(response(1),scatter(1),pulse.f,dispFig)

%% Clear variables
pulse = rmfield(pulse,'dispProgress');
clear dispFig dispProgress nearfield
clear invertedPulse Nenv Ncy PA f Fs Tresp Hfit T 

%% FUNCTIONS
function shell = get_shell_properties_multi(bubble,shellmodel,sig0,liquid)
% Get the shell properties for multiple bubbles in a single array struct.

N_MB = length(bubble);         % Number of bubbles

for n = N_MB:-1:1
    shell.model = shellmodel;  % Marmottant, Segers, or SegersTable
    shell.sig_0 = sig0;        % Equilibrium surface tension bubble (N/m);
    shell = getShellProperties(bubble(n),shell,liquid);
    
    shells(n) = shell;
end

shell = shells;

end

function pulse = getPulseMulti(f,Ncy,PA,Fs,Tresp,dispFig,Tfit)
% Get a pulse struct containing waveforms with different acoustic pressure
% amplitudes.

Npulse = length(PA); % Number of waveforms

for n = Npulse:-1:1
    % Simulate the pulse generated by a transducer with transfer function
    % T, resulting from a three-level driving signal:
    pulses(n) = getPulse(f,Ncy,PA(n),Fs,Tresp,dispFig,Tfit);   
end

% Create a single pulse structure:
pulse.t  = pulses(1).t; % Common time array
pulse.fs = pulses(1).fs;
pulse.f  = pulses(1).f; % Only valid if all centre frequencies equal
pulse.w  = pulses(1).w; % Only valid if all centre frequencies equal

% Assign waveforms to pulse struct:
Nt = length(pulses(1).t); % Only valid if all waveforms have same length
pulse.p = zeros(Npulse,Nt);

for n = 1:Npulse
    pulse.p(n,:) = pulses(n).p;
end

end

function [response, eqparam] = calcBubbleResponseBatched(...
    liquid, gas, shell, bubble, pulse)
% Compute the response of a large number of microbubbles by dividing them
% into batches. Each batch is solved with a single call to the ODE solver.

N_MB  = length(bubble);      % Total number of bubbles
radii = [bubble.R0];         % Bubble radii [m]

batchSize = pulse.batchSize;
Nbatch = ceil(N_MB/batchSize);   % Total number of batches

% Write the simulation parameters to cell arrays, each cell
% holding the values for one batch:
bubble_cell   = cell(1,Nbatch);
shell_cell    = cell(1,Nbatch);
pulse_cell    = cell(1,Nbatch);

for k = 1:Nbatch
    % Microbubble indices in the current batch:
    idx = get_batch_indices(k, N_MB, batchSize, radii);

    bubble_cell{k}   = bubble(idx);
    shell_cell{k}    = shell(idx);
    
    pulse_cell{k}    = pulse;
    pulse_cell{k}.p  = pulse.p(idx,:);
end

% Cell array for holding the results of the for loop:
response_cell = cell(1,Nbatch);
eqparam_cell  = cell(1,Nbatch);

% Loop through all the bubble batches:
parfor k = 1:Nbatch

    disp(['Simulating microbubble batch ' ...
        num2str(k) '/' num2str(Nbatch) ' ...'])
   
    % Compute the bubble response:
    [response_cell{k}, eqparam_cell{k}] = calcBubbleResponse(liquid, ...
        gas, shell_cell{k}, bubble_cell{k}, pulse_cell{k});

end

for k = Nbatch:-1:1
    % Microbubble indices in the current batch:
    idx = get_batch_indices(k, N_MB, batchSize, radii);
    response(idx) = response_cell{k};
    eqparam(idx)  = eqparam_cell{k};
end

end
